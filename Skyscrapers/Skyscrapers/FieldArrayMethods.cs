using static Skyscrapers.Constants;
using static Skyscrapers.Global;

namespace Skyscrapers
{
    public class FieldArrayMethods
    {
        /// <summary>
        /// Method, that generates numbers by random from left-up corner, to right-down corner, excluding exceptions
        /// </summary>
        /// <param name="size"></param>
        /// <returns></returns>
        public static int[,] FieldArrayLRUD(int size)
        {
            int[,] output = new int[size, size];
            for (int i = 0; i < size; i++)
            {
                for (int j = 0; j < size; j++)
                {
                    output[i, j] = RandomNumber(size, Exceptions(output, i, j));
                }
            }
            return output;
        }
        public static void PushElement(ref int[,] array, int size)
        {
            int min = size;
            int inclusionsLength;
            for(int i = 0; i < size; i++)
            {
                for(int j = 0; j < size; j++)
                {
                    inclusionsLength = Inclusions(array, i, j).Length;
                    if(inclusionsLength < min)
                    {
                        min = inclusionsLength;
                    }
                }
            }
            int counter = 0;
            for(int i = 0; i < size; i++)
            {
                for(int j = 0; j < size; j++)
                {
                    if(Inclusions(array, i, j).Length == min)
                    {
                        counter++;
                    }
                }
            }
            if(counter == 0) { return; }
            int[,] allInclusions = new int[counter, min + 2];
            int[] tempInclusions;
            counter = 0;
            for (int i = 0; i < size; i++)
            {
                for (int j = 0; j < size; j++)
                {
                    tempInclusions = Inclusions(array, i, j);
                    if(tempInclusions.Length == min)
                    {
                        allInclusions[counter, 0] = i;
                        allInclusions[counter, 1] = j;
                        for(int k = 0; k < min; k++)
                        {
                            allInclusions[counter, k + 2] = tempInclusions[k];
                        }
                        counter++;
                    }
                }
            }
            int x, y;
            if (min == 1)
            {
                for (int i = 0; i < counter; i++)
                {
                    x = allInclusions[i, 0];
                    y = allInclusions[i, 1];
                    array[x, y] = allInclusions[i, 2];
                }
                return;
            }
            int randomIndex = random.Next(counter);
            x = allInclusions[randomIndex, 0];
            y = allInclusions[randomIndex, 1];
            int randomNumber = random.Next(2, min + 2);
            try { array[x, y] = allInclusions[randomIndex, randomNumber]; }
            catch {}
            return;
        }
        public static int[,] FieldArrayRandMin(int size)
        {
            int[,] output = new int[size, size];
            for (int i = 0; i < size * size; i++)
            {
                PushElement(ref output, size);
            }
            return output;
        }
        /// <summary>
        /// Unificaton all types of generation field, with possibility check runtime
        /// </summary>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="isDebug"></param>
        /// <returns></returns>
        public static int[,] FieldArray(int size, types type, bool isDebug = false)
        {
            long starttime = 0;
            if (isDebug)
            {
                starttime = DateTime.Now.Ticks;
            }
            int[,] output = new int[0,0];
            switch (type)
            {
                case types.lrud:
                    do {
                        output = FieldArrayLRUD(size);
                    } while (DetectInArray(output, -1));
                    break;
                case types.randmin:
                    do {
                        output = FieldArrayRandMin(size);
                    } while (DetectInArray(output, 0));
                    break;
                default:
                    break;
            }
            if (isDebug)
            {
                long endtime = DateTime.Now.Ticks;
                long delta = endtime - starttime;
                Console.WriteLine($"Field generated by type {type} with size {size} in time {delta}");
            }
            return output;
        }
        /// <summary>
        /// User-interface field
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static int[,] FieldForGame(int[,] array)
        {
            int sizeX = array.GetLength(0);
            int sizeY = array.GetLength(1);
            int[,] output = new int[sizeX + 2, sizeY + 2];
            int temp = 0;
            int counter = 0;
            for (int i = 0; i < sizeX; i++)
            {
                for (int j = 0; j < sizeY; j++)
                {
                    if (array[i, j] > temp)
                    {
                        temp = array[i, j];
                        counter++;
                    }
                }
                output[i + 1, 0] = counter;
                temp = 0;
                counter = 0;
            }
            for (int i = 0; i < sizeX; i++)
            {
                for (int j = sizeY - 1; j >= 0; j--)
                {
                    if (array[i, j] > temp)
                    {
                        temp = array[i, j];
                        counter++;
                    }
                }
                output[i + 1, sizeY + 1] = counter;
                temp = 0;
                counter = 0;
            }
            for (int j = 0; j < sizeY; j++)
            {
                for (int i = 0; i < sizeX; i++)
                {
                    if (array[i, j] > temp)
                    {
                        temp = array[i, j];
                        counter++;
                    }
                }
                output[0, j + 1] = counter;
                temp = 0;
                counter = 0;
            }
            for (int j = 0; j < sizeY; j++)
            {
                for (int i = sizeX - 1; i >= 0; i--)
                {
                    if (array[i, j] > temp)
                    {
                        temp = array[i, j];
                        counter++;
                    }
                }
                output[sizeX + 1, j + 1] = counter;
                temp = 0;
                counter = 0;
            }
            return output;
        }
    }
}
